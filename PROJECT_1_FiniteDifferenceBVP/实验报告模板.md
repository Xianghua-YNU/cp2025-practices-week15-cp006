# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** [刘睿]
**学号：** [20231050209]
**完成日期：** [2025/6/6]

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
[在此处简述有限差分法的核心思想，例如：如何将连续的微分方程离散化为线性方程组，如何处理边界条件，以及如何求解得到的线性系统。]
有限差分法核心是把连续的微分方程离散化。对于二阶常微分方程边值问题，先在求解区间创建网格，将区间离散成一系列点 。通过有限差分近似（如用中心差分近似导数，y''_i ≈ (y_{i + 1} - 2*y_i + y_{i - 1}) / h^2 、y'_i ≈ (y_{i + 1} - y_{i - 1}) / (2*h) ），把微分方程转化为关于内部网格点函数值的线性方程组（构建系数矩阵 A 和右端向量 b ）。处理边界条件时，将边界点的函数值代入方程，修正线性方程组的 b 向量。最后求解线性方程组，得到内部点的函数值，再结合边界点值得到完整解。

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现有限差分法核心逻辑的代码片段
# 例如 solve_bvp_finite_difference 中构建系数矩阵和右端向量的关键部分
def solve_bvp_finite_difference(n):
    """
    使用有限差分法求解二阶常微分方程边值问题。
    
    方程：y''(x) + sin(x) * y'(x) + exp(x) * y(x) = x^2
    边界条件：y(0) = 0, y(5) = 3
    
    Args:
        n (int): 内部网格点数量
    
    Returns:
        tuple: (x_grid, y_solution)
            x_grid (np.ndarray): 包含边界点的完整网格
            y_solution (np.ndarray): 对应的解值
    """
    # Step 1: 创建网格
    h = 5.0 / (n + 1)
    x_grid = np.linspace(0, 5, n + 2)
    
    # Step 2: 构建系数矩阵 A 和右端向量 b
    A = np.zeros((n, n))
    b = np.zeros(n)
    
    # Step 3: 填充矩阵 A 和向量 b
    for i in range(n):
        x_i = x_grid[i + 1]  # 内部点的 x 坐标
        
        # 系数计算
        # y''_i ≈ (y_{i+1} - 2*y_i + y_{i-1}) / h^2
        # y'_i ≈ (y_{i+1} - y_{i-1}) / (2*h)
        # 方程: y''(x) + sin(x) * y'(x) + exp(x) * y(x) = x^2
        # 重新整理: (1/h^2 - sin(x_i)/(2*h)) * y_{i-1} + (-2/h^2 + exp(x_i)) * y_i + (1/h^2 + sin(x_i)/(2*h)) * y_{i+1} = x_i^2
        
        coeff_left = 1.0 / h**2 - np.sin(x_i) / (2.0 * h)
        coeff_center = -2.0 / h**2 + np.exp(x_i)
        coeff_right = 1.0 / h**2 + np.sin(x_i) / (2.0 * h)
        
        # 填充矩阵 A
        if i > 0:
            A[i, i-1] = coeff_left
        A[i, i] = coeff_center
        if i < n - 1:
            A[i, i+1] = coeff_right
        
        # 填充右端向量 b
        b[i] = x_i**2
        
        # 处理边界条件
        if i == 0:  # 第一个内部点，需要考虑左边界 y_0 = 0
            b[i] -= coeff_left * 0.0
        if i == n - 1:  # 最后一个内部点，需要考虑右边界 y_{n+1} = 3
            b[i] -= coeff_right * 3.0
    
    # Step 4: 求解线性系统
    y_interior = solve(A, b)
    
    # Step 5: 组合完整解
    y_solution = np.zeros(n + 2)
    y_solution[0] = 0.0  # 左边界
    y_solution[1:-1] = y_interior  # 内部点
    y_solution[-1] = 3.0  # 右边界
    
    return x_grid, y_solution
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
[在此处简述你是如何使用 `solve_bvp` 函数的，例如：如何定义ODE系统函数和边界条件函数，以及如何设置初始猜测。]
先将二阶常微分方程转化为一阶 ODE 系统（通过 ode_system_for_solve_bvp 函数，把 y'' 相关方程转换为 y 和 y' 的一阶导数形式 ）。然后定义边界条件函数（boundary_conditions_for_solve_bvp ），指定左右边界处函数应满足的残差（如左边界 y(0)=0 、右边界 y(5)=3 ）。接着创建初始网格和初始猜测（包括 y 和 y' 的初始值 ），最后调用 solve_bvp 函数，传入 ODE 系统、边界条件、初始网格和猜测，求解得到结果后提取 y(x) 的解。

**关键代码片段 (可选)：**
```python
# 粘贴1-2个你认为最能体现 solve_bvp 使用方法的代码片段
# 例如 ode_system_for_solve_bvp 或 boundary_conditions_for_solve_bvp
def ode_system_for_solve_bvp(x, y):
    """
    为 scipy.integrate.solve_bvp 定义ODE系统。
    
    将二阶ODE转换为一阶系统：
    y[0] = y(x)
    y[1] = y'(x)
    
    系统方程：
    dy[0]/dx = y[1]
    dy[1]/dx = -sin(x) * y[1] - exp(x) * y[0] + x^2
    
    Args:
        x (float or array): 自变量
        y (array): 状态变量 [y, y']
    
    Returns:
        array: 导数 [dy/dx, dy'/dx]
    """
    y0 = y[0]  # y(x)
    y1 = y[1]  # y'(x)
    
    dy0_dx = y1
    dy1_dx = -np.sin(x) * y1 - np.exp(x) * y0 + x**2
    
    return np.vstack([dy0_dx, dy1_dx])

def boundary_conditions_for_solve_bvp(ya, yb):
    """
    为 scipy.integrate.solve_bvp 定义边界条件。
    
    Args:
        ya (array): 左边界处的状态 [y(0), y'(0)]
        yb (array): 右边界处的状态 [y(5), y'(5)]
    
    Returns:
        array: 边界条件残差 [y(0) - 0, y(5) - 3]
    """
    return np.array([ya[0] - 0, yb[0] - 3])

def solve_bvp_scipy(n_initial_points=11):
    """
    使用 scipy.integrate.solve_bvp 求解BVP。
    
    Args:
        n_initial_points (int): 初始网格点数
    
    Returns:
        tuple: (x_solution, y_solution)
            x_solution (np.ndarray): 解的 x 坐标数组
            y_solution (np.ndarray): 解的 y 坐标数组
    """
    # Step 1: 创建初始网格
    x_initial = np.linspace(0, 5, n_initial_points)
    
    # Step 2: 创建初始猜测
    y_initial = np.zeros((2, n_initial_points))
    y_initial[0] = np.linspace(0, 3, n_initial_points)  # y(x) 的初始猜测
    y_initial[1] = np.ones(n_initial_points) * 0.6      # y'(x) 的初始猜测
    
    # Step 3: 调用 solve_bvp
    solution = solve_bvp(ode_system_for_solve_bvp, boundary_conditions_for_solve_bvp, 
                         x_initial, y_initial)
    
    # Step 4: 提取解
    if solution.success:
        x_solution = solution.x
        y_solution = solution.y[0]  # 只取 y(x)，不要 y'(x)
        return x_solution, y_solution
    else:
        raise RuntimeError("solve_bvp failed to converge")

```

## 3. 实验结果与分析

### 3.1 数值解的可视化

[在此处粘贴你生成的包含两种方法数值解的比较图。确保图表清晰，包含标题、坐标轴标签和图例。]
![image](https://github.com/user-attachments/assets/81eb4752-8d45-4125-9b8e-209b1e827378)


**(图片粘贴区域)**

### 3.2 结果比较与讨论

[针对你得到的数值解进行比较和讨论。例如：
- 两种方法得到的结果是否一致？如果存在差异，可能的原因是什么？
- 答：从图像看，有限差分法（蓝色实线）与 scipy.integrate.solve_bvp（红色虚线）结果存在明显差异。
原因在于：有限差分法通过离散网格点构建线性方程组求解，网格点数（代码中 num_points 相关设置 ）影响离散精度，若网格点少，近似误差大；solve_bvp 是自适应算法，依赖初始猜测和内部迭代调整，初始猜测（如代码里 y_initial 对 y 和 y' 的设置 ）、算法迭代收敛性等会使结果不同，且它对 ODE 系统的数值积分和边界条件处理方式与有限差分法的离散化思路本质不同。
- 你是如何选择离散点数 `n_points` 的？它对解的精度和计算时间有何影响（如果进行了探究）？
- 答：选择方式：代码里凭经验选初始离散点数（如有限差分法用 num_points - 2 做内部网格点，solve_bvp 用 n_initial_points=11 初始网格 ），未严格理论推导，主要考虑计算耗时和初步精度验证，先选较小值测试，再根据需求调整。
      对解的影响：对有限差分法，网格点越多（离散点数增加 ），离散近似越接近连续方程，精度理论上越高，但计算量随网格点增多而增大（构建和求解线性方程组耗时增加 ）；solve_bvp 中初始离散点数影响初始网格密度，点数少可能因初始信息不足导致收敛差，点数合适能辅助算法更好迭代，不过该函数内部有自适应调整网格机制，初始点数影响相对有限，但也会间接影响计算时间和收敛结果。
- 对于有限差分法，网格点数对解的精度有何影响？边界条件是如何处理的？
- 答：网格点数对精度影响：网格点数越多，差分近似越精准，解越接近真实值。比如网格点少，用中心差分近似导数时误差大，累积后解偏差明显；网格点足够多，离散方程更贴合原微分方程，精度提升。
      边界条件处理：代码中，左边界 y(0)=0 、右边界 y(5)=3 直接代入线性方程组构建。处理第一个内部点（i=0 ）时，把左边界值代入修正 b 向量；处理最后一个内部点（i = n - 1 ）时，用右边界值修正 b 向量，以此将边界条件融入离散后的线性方程组。
- 对于 `solve_bvp`，初始猜测对结果的影响如何？收敛性如何？
- 答：初始猜测影响：初始猜测（y_initial 里 y 和 y' 的初始值 ）是算法迭代起点。若初始猜测合理（如代码中 y 按边界线性变化、y' 设为常数 ），算法易收敛到正确解；若猜测偏差大，可能使迭代陷入局部，甚至不收敛。比如把 y' 初始猜测设为不合理值，可能让中间迭代解偏离真实解，增加收敛难度。
      收敛性：solve_bvp 是基于数值积分和迭代修正的算法，若问题本身适定（边界条件合理、ODE 系统连续可微等 ），且初始猜测不过于离谱，通常能收敛。但像本问题中两种方法结果差异大，可能是初始猜测或算法内部迭代适配性导致收敛到不同近似解，也可能因问题复杂度（方程含 sin(x) 、exp(x) 等非线性项 ），增加了收敛难度和结果不确定性。
- 哪种方法你认为最容易实现？哪种方法最鲁棒或最高效？]
- 答：实现难度：有限差分法更易实现。只需理解差分近似原理，手动构建系数矩阵和右端向量，处理边界条件逻辑相对直接；solve_bvp 需掌握将二阶 ODE 转化为一阶系统，定义边界条件函数，还要合理设置初始猜测，对 ODE 系统转换和算法调用细节要求更高。
      鲁棒性与高效性：solve_bvp 更鲁棒、高效。它是成熟数值算法，内部有自适应网格调整、迭代优化机制，应对复杂问题（如非线性项多、解变化剧烈 ）时，能自动调整计算策略保证精度；有限差分法依赖网格离散，网格不合适易误差大，且处理高维、复杂边界问题时，手动构建矩阵难度剧增，计算效率随网格加密快速下降，相比之下，solve_bvp 更适合工程化、复杂 BVP 求解

### 3.3 (可选) 精度分析

[如果你找到了问题的解析解或高精度参考解，并进行了误差分析，请在此处展示你的结果和讨论。例如，比较不同方法的误差大小，分析误差随离散点数的变化等。]

## 4.遇到的问题与解决方法

**主要问题：**
[列出你在项目过程中遇到的1-2个主要技术问题或理解上的难点。]
答：主要问题
1.有限差分法矩阵构建易错：手动构建系数矩阵 A 和右端向量 b 时，边界条件处理逻辑复杂，比如在循环中判断 i=0 和 i = n - 1 时修正 b 向量，容易因索引错误、系数计算错误，导致矩阵维度不匹配、线性方程组求解报错。
2.solve_bvp 收敛失败或结果异常：初始猜测设置不合理时，solve_bvp 可能不收敛（如报错提示迭代未收敛 ），或收敛到与预期差异大的结果（像图像中与有限差分法结果背离 ），不确定是初始猜测、ODE 系统定义，还是边界条件函数的问题。

**解决方法：**
[描述你是如何思考并解决这些问题的。]
答：解决方法
1.矩阵构建问题：逐行检查矩阵构建逻辑，打印 A 和 b 的形状、部分元素值，验证系数计算（如 coeff_left 、coeff_center 、coeff_right ）是否符合差分近似公式，边界条件修正 b 向量的步骤是否正确。通过小网格点数（如 n=2 、n=3 ）测试，手动推导离散方程，对比代码计算结果，定位并修正错误。
2.solve_bvp 收敛问题：调整初始猜测，尝试不同 y 和 y' 初始值（如改变 y_initial[1] 的常数、让 y 初始猜测更贴合解的趋势 ）；检查 ODE 系统定义，确保一阶转换正确（验证 dy0_dx 、dy1_dx 推导 ）；查看边界条件函数，保证残差计算符合边界要求（如 ya[0] - 0 、yb[0] - 3 ）。多次测试不同初始参数，结合函数文档（如 solve_bvp 对初始猜测、问题适定性的要求 ），逐步排查解决。


## 5. 总结与心得体会

**主要收获：**
[总结通过这个项目你学到了哪些关于BVP数值解法的重要知识和技能。例如：对不同方法原理的深入理解、编程实现能力的提升、调试技巧、对数值误差和稳定性的认识等。3-5句话即可。]
答：通过本次项目，深入理解了 BVP 数值解法的两类典型方法：有限差分法需手动离散化微分方程，核心是构建线性方程组，对离散思想和边界条件处理要求细致，能直观感受微分方程离散过程，但实现复杂、鲁棒性依赖网格设计；scipy.integrate.solve_bvp 则借助成熟数值算法，简化了求解流程，不过需掌握 ODE 系统转换、初始猜测设置等技巧。编程实现中，调试矩阵构建、处理 solve_bvp 收敛问题，提升了代码调试和问题定位能力，也认识到数值解法精度、效率与算法原理、参数设置（如离散点数、初始猜测 ）密切相关，不同方法各有优劣，需依问题场景选择。

